---
title: "TERGM"
output: html_document
---


```{r}
# install.packages(c("network", "btergm", "tergm", "ggraph", "intergraph"))
```


```{r}
#install.packages(c("ggraph", "intergraph"))
```

```{r}
library(network)
library(btergm)
library(sna)
library(igraph)
library(ggraph)
library(intergraph)
```


```{r}
edges_t1 <- read.csv("edge_list_data_2010.csv")
edges_t2 <- read.csv("edge_list_data_2020.csv")
```

The `echo: false` option disables the printing of code (only output is displayed).

```{r}
#head(edges_t1)
dim(edges_t2)  
```
```{r}
nodes <- unique(c(edges_t1$from, edges_t1$to, edges_t2$from, edges_t2$to))
node_df <- data.frame(name = nodes)
```

```{r}
length(nodes)
```

```{r}
net1 <- network(edges_t1, directed = TRUE, vertices = node_df, matrix.type = "edgelist")
net2 <- network(edges_t2, directed = TRUE, vertices = node_df, matrix.type = "edgelist")

network::set.edge.attribute(net1, "weight", edges_t1$weight)
network::set.edge.attribute(net2, "weight", edges_t2$weight)
```

```{r}
net.list <- list(net1, net2)
```


```{r}
# === 6. (선택) 예시 공변량 생성 ===
# 두 시점마다 동일 크기의 행렬 리스트로 생성해야 함
set.seed(123)
X1 <- matrix(runif(length(nodes)^2, 0, 1), nrow = length(nodes))
X2 <- matrix(runif(length(nodes)^2, 0, 1), nrow = length(nodes))
X.list <- list(X1, X2)

# === 7. TERGM (btergm) 모델 추정 ===
model <- btergm(net.list ~ edges + gwesp(0.5, fixed = TRUE) + edgecov(X.list), R = 100)

# === 8. 결과 확인 ===
summary(model)
```

```{r}
# nsim = 생성할 네트워크 수 (기본값은 1)
sim <- simulate(model, nsim = 1)

# === 2. 결과 확인 ===
# sim은 네트워크 객체 형태의 리스트로 반환됩니다.
class(sim)       # "list"
length(sim)      # 예: 1
class(sim[[1]])  # "network"

```
```{r}
str(sim, max.level = 1)
```

```{r}
# 첫 번째 시뮬레이션 네트워크 꺼내기
net_pred <- sim

# 타입 확인
class(net_pred)
# [1] "network"

# 시각화
deg <- sna::degree(net_pred, gmode = "digraph")

#plot.network(net_pred,
#             displaylabels = TRUE,
#             vertex.col = "skyblue",
#             label.cex = 0.6,
#            main = "Predicted Network (Next Time Step)")


# network 객체 → igraph 변환
g <- asIgraph(net_pred)

if (is.null(V(g)$name)) {
  V(g)$name <- network.vertex.names(net_pred)
}

# 중심성 계산 (노드 크기용)
deg <- degree(g, mode = "all")

# 시각화
ggraph(g, layout = "fr") +  # "fr" = Fruchterman-Reingold layout
  geom_edge_link(aes(alpha = 0.3), colour = "gray60") +
  geom_node_point(aes(size = deg), colour = "skyblue") +
  geom_node_text(aes(label = name), repel = TRUE, size = 3) +
  theme_void() +
  ggtitle("Predicted Network (Clean Layout)") +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16)
  )

```
```{r}
network.vertex.names(net_pred)
```



```{r}
plot.network(net2,
            #vertex.cex = (deg / max(deg)) * 3,
             displaylabels = TRUE,
             vertex.col = "skyblue",
             label.cex = 0.6,
             main = "TPU Network : 2020 ~")
```
```{r}
deg <- sna::degree(net1, gmode = "digraph")
plot.network(net1,
            # vertex.cex = (deg / max(deg)) * 3,
             displaylabels = TRUE,
             vertex.col = "skyblue",
             label.cex = 0.6,
             main = "TPU Network : 2010 ~")
```